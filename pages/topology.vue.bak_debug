<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'

interface Node {
  id: string
  type: string
  name: string
  x: number
  y: number
}

interface Connection {
  from: string
  to: string
}

const nodes = ref<Node[]>([])
const connections = ref<Connection[]>([])
const selectedNodeId = ref<string | null>(null)
const terraformCode = ref('')
const showTerraform = ref(false)

// Drag & Drop State
const isDragging = ref(false)
const dragOffset = ref({ x: 0, y: 0 })
const draggedNodeId = ref<string | null>(null)

// Connection Mode State
const isConnecting = ref(false)
const connectionStartNodeId = ref<string | null>(null)
const mousePos = ref({ x: 0, y: 0 }) // For drawing the temp line

const canvasRef = ref<HTMLElement | null>(null)

const serviceTypes = [
  { type: 'watson', name: 'Watson Assistant', icon: 'ü§ñ', color: 'var(--ibm-purple-60)' },
  { type: 'kubernetes', name: 'Kubernetes/ROKS', icon: '‚ò∏Ô∏è', color: 'var(--ibm-blue-60)' },
  { type: 'cloudant', name: 'Cloudant/Db2', icon: 'üóÑÔ∏è', color: 'var(--ibm-green-60)' },
  { type: 'storage', name: 'Object Storage', icon: 'üì¶', color: 'var(--ibm-blue-50)' },
  { type: 'eventstreams', name: 'Event Streams', icon: 'üì®', color: 'var(--ibm-purple-50)' }
]

// --- Node Management ---

const addNode = (type: string, name: string) => {
  const node: Node = {
    id: `node-${Date.now()}`,
    type,
    name,
    x: 50 + Math.random() * 50,
    y: 50 + Math.random() * 50
  }
  nodes.value.push(node)
  selectedNodeId.value = node.id
}

const removeNode = (id: string) => {
  nodes.value = nodes.value.filter(n => n.id !== id)
  connections.value = connections.value.filter(c => c.from !== id && c.to !== id)
  if (selectedNodeId.value === id) selectedNodeId.value = null
}

const getNodeColor = (type: string) => {
  return serviceTypes.find(s => s.type === type)?.color || 'var(--ibm-gray-50)'
}

const selectNode = (id: string) => {
    if (isConnecting.value && connectionStartNodeId.value) {
        // Complete connection
        if (connectionStartNodeId.value !== id) {
             // Check if exists
             const exists = connections.value.find(c => c.from === connectionStartNodeId.value && c.to === id)
             if (!exists) {
                 connections.value.push({ from: connectionStartNodeId.value, to: id })
             }
        }
        isConnecting.value = false
        connectionStartNodeId.value = null
        return
    }
    selectedNodeId.value = id
}

// --- Interaction Handlers ---

const startDrag = (event: MouseEvent, node: Node) => {
  if (isConnecting.value) return // Don't drag if connecting

  isDragging.value = true
  draggedNodeId.value = node.id
  selectedNodeId.value = node.id
  
  // Calculate offset relative to node top-left
  dragOffset.value = {
    x: event.clientX - node.x,
    y: event.clientY - node.y
  }
}

const onCanvasMouseMove = (event: MouseEvent) => {
    // Update mouse pos for temp connection line
    if (canvasRef.value) {
        const rect = canvasRef.value.getBoundingClientRect()
        mousePos.value = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        }
    }

  if (isDragging.value && draggedNodeId.value) {
      if (!canvasRef.value) return
      
      const node = nodes.value.find(n => n.id === draggedNodeId.value)
      if (node) {
        // Simple snapping or direct follow
        // We could limit bounds here
        node.x = event.clientX - dragOffset.value.x
        node.y = event.clientY - dragOffset.value.y
      }
  }
}

const onCanvasMouseUp = () => {
    isDragging.value = false
    draggedNodeId.value = null
}

const startConnection = (nodeId: string, event: MouseEvent) => {
    event.stopPropagation() // Prevent selecting node
    isConnecting.value = true
    connectionStartNodeId.value = nodeId
}

const cancelConnection = () => {
    isConnecting.value = false
    connectionStartNodeId.value = null
}

// Global listener for mouseup to catch drops outside elements
onMounted(() => {
    window.addEventListener('mouseup', onCanvasMouseUp)
    window.addEventListener('mousemove', onCanvasMouseMove)
})

onUnmounted(() => {
    window.removeEventListener('mouseup', onCanvasMouseUp)
    window.removeEventListener('mousemove', onCanvasMouseMove)
})


// --- Terraform ---

const generateTerraform = () => {
  let code = '# IBM Cloud Topology - Generated by IBM Ease\n\n'
  code += 'terraform {\n  required_providers {\n    ibm = {\n      source = "IBM-Cloud/ibm"\n      version = "~> 1.59.0"\n    }\n  }\n}\n\n'
  code += 'variable "region" { default = "us-south" }\n'
  code += 'variable "resource_group_id" {}\n\n'
  code += 'provider "ibm" {\n  region = var.region\n}\n\n'

  nodes.value.forEach(node => {
      const safeName = node.name.toLowerCase().replace(/[^a-z0-9]/g, '_')
      
      code += `resource "ibm_${node.type}" "${safeName}_${node.id.split('-')[1]}" {\n`
      code += `  name              = "${node.name}"\n`
      code += `  resource_group_id = var.resource_group_id\n`
      code += `  # Position: x=${Math.round(node.x)}, y=${Math.round(node.y)}\n`
      
      // Look for dependencies
      const deps = connections.value.filter(c => c.to === node.id)
      if (deps.length > 0) {
          code += `  depends_on        = [ ${deps.map(d => {
              const pNode = nodes.value.find(n => n.id === d.from)
              if(!pNode) return ''
              const pSafeName = pNode.name.toLowerCase().replace(/[^a-z0-9]/g, '_')
              return `ibm_${pNode.type}.${pSafeName}_${pNode.id.split('-')[1]}`
          }).join(', ')} ]\n`
      }
      
      code += `}\n\n`
  })

  terraformCode.value = code
  showTerraform.value = true
}

// Helper to get center of a node for lines
const getNodeCenter = (nodeId: string) => {
    const node = nodes.value.find(n => n.id === nodeId)
    if (!node) return { x: 0, y: 0 }
    
    return {
        x: node.x + 100, // half width
        y: node.y + 40 // approx half height
    }
}

const handleTopologyUpdate = (data: any) => {
    if (data.nodes && Array.isArray(data.nodes)) {
        nodes.value = data.nodes
    }
    if (data.connections && Array.isArray(data.connections)) {
        connections.value = data.connections
    }
}
</script>

<template>
  <div class="container">
    <section class="section-header">
      <div class="header-content">
        <h2 class="section-title">Cloud Topology Builder</h2>
        <p class="header-sub">Design IBM Cloud architecture visually. Drag, drop, and connect.</p>
      </div>
      <div class="header-actions">
         <span class="badge">Canvas Alpha</span>
      </div>
    </section>

    <div class="topology-grid">
      <!-- Tool Palette -->
      <section class="card tool-palette">
        <h3 class="card-title">Services</h3>
          <div class="services-list">
            <button
              v-for="service in serviceTypes"
              :key="service.type"
              class="service-btn"
              @click="addNode(service.type, service.name)"
            >
              <span class="service-icon">{{ service.icon }}</span>
              <span class="service-name">{{ service.name }}</span>
            </button>
          </div>

          <div class="palette-actions">
            <button class="primary-btn full-width" @click="generateTerraform" :disabled="nodes.length === 0">
              Generate Terraform
            </button>
          </div>
        </section>

        <!-- Canvas -->
        <section class="card canvas-container">
          <div ref="canvasRef" class="canvas" :class="{ 'connecting-mode': isConnecting }" @click="cancelConnection">
             <!-- SVG Layer for Connections -->
             <svg class="connections-layer">
                 <defs>
                     <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                         <polygon points="0 0, 10 3.5, 0 7" fill="#c6c6c6" />
                     </marker>
                 </defs>
                 
                 <!-- Existing Connections -->
                 <line 
                   v-for="(conn, idx) in connections"
                   :key="idx"
                   :x1="getNodeCenter(conn.from).x"
                   :y1="getNodeCenter(conn.from).y"
                   :x2="getNodeCenter(conn.to).x"
                   :y2="getNodeCenter(conn.to).y"
                   stroke="#c6c6c6"
                   stroke-width="2"
                   marker-end="url(#arrowhead)"
                 />

                 <!-- Temp Connection Line -->
                 <line 
                   v-if="isConnecting && connectionStartNodeId"
                   :x1="getNodeCenter(connectionStartNodeId).x"
                   :y1="getNodeCenter(connectionStartNodeId).y"
                   :x2="mousePos.x"
                   :y2="mousePos.y"
                   stroke="#4589ff"
                   stroke-width="2"
                   stroke-dasharray="5,5"
                 />
             </svg>

            <div
              v-for="node in nodes"
              :key="node.id"
              class="node"
              :class="{ selected: selectedNodeId === node.id }"
              :style="{
                left: node.x + 'px',
                top: node.y + 'px',
                borderColor: selectedNodeId === node.id ? '#4589ff' : '#393939'
              }"
              @mousedown.stop="startDrag($event, node)"
              @click.stop="selectNode(node.id)"
            >
              <div class="node-header" :style="{ background: getNodeColor(node.type) }">
                <span>{{ serviceTypes.find(s => s.type === node.type)?.icon }}</span>
                <span style="font-size: 12px; font-weight: 600; color: #fff;">{{ node.type }}</span>
                <div class="node-actions">
                    <!-- Connect Button -->
                    <button class="node-action-btn" title="Connect" @mousedown.stop @click.stop="startConnection(node.id, $event)">
                        üîó
                    </button>
                    <button class="node-close" @mousedown.stop @click.stop="removeNode(node.id)">√ó</button>
                </div>
              </div>
              <div class="node-body">
                <div class="node-name">{{ node.name }}</div>
                <div class="node-id">{{ node.id.split('-')[1] }}</div>
              </div>
            </div>

            <div v-if="nodes.length === 0" class="canvas-empty">
              <div class="empty-icon">üèóÔ∏è</div>
              <div class="empty-title">Start building</div>
              <div class="empty-sub">Drag services or ask AI ‚Üí</div>
            </div>
            
            <div v-if="isConnecting" class="connection-hint">
              Select a target node to connect... (Click background to cancel)
            </div>
          </div>
        </section>
        
        <!-- AI Assistant -->
        <section class="card ai-panel">
            <h3 class="card-title">AI Architect</h3>
            <div class="ai-container">
                 <AIChat mode="topology" @update="handleTopologyUpdate"></AIChat>
            </div>
        </section>
      </div>

      <section v-if="showTerraform" class="card terraform-modal">
        <div class="modal-header">
          <h3 class="card-title">Generated Terraform</h3>
          <button class="secondary-btn small" @click="showTerraform = false">Close</button>
        </div>
        <pre class="code-block">{{ terraformCode }}</pre>
        <button class="primary-btn" style="margin-top: 16px;">Download .tf files</button>
      </section>
    </div>
  </div>
</template>


<style scoped>
/* Page Layout */
/* .topology-wrapper removed, uses global body */

/* .topology-container removed, uses global .container */

/* Header */
.section-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 32px;
}

/* badge is global */

/* Grid Layout */
.topology-grid {
  display: grid;
  grid-template-columns: 280px 1fr 320px;
  gap: 16px;
  height: calc(100vh - 200px);
  min-height: 600px;
}

/* Card Styling */
/* .topology-card removed, uses global .card */

.card-title {
  font-size: 14px;
  font-weight: 600;
  color: #f4f4f4;
  margin: 0 0 16px;
  letter-spacing: 0.16px;
}

/* Tool Palette */
.services-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex: 1;
  overflow-y: auto;
}

.service-btn {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border: 1px solid transparent;
  background: #393939; /* Gray 80 */
  color: #f4f4f4;
  cursor: pointer;
  transition: all 0.1s;
  font-size: 13px;
  text-align: left;
}

.service-btn:hover {
  background: #4c4c4c; /* Gray 70 */
}

.service-icon {
  font-size: 18px;
}

.palette-actions {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #393939;
}

/* Canvas */
.canvas-container {
  padding: 0;
  border: 1px solid #393939;
  overflow: hidden;
  position: relative;
}

.canvas {
  position: relative;
  width: 100%;
  height: 100%;
  background-color: #161616;
  background-image: radial-gradient(#393939 1px, transparent 1px);
  background-size: 20px 20px;
  overflow: hidden;
}

.canvas.connecting-mode {
    cursor: crosshair;
}

.connections-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
}

.canvas-empty {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  pointer-events: none;
}

.empty-icon {
  font-size: 40px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.empty-title {
  font-size: 16px;
  font-weight: 600;
  color: #f4f4f4;
  margin-bottom: 8px;
}

.empty-sub {
  color: #c6c6c6;
  font-size: 14px;
}

.connection-hint {
    position: absolute;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    background: #393939;
    color: #f4f4f4;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 10;
    border: 1px solid #525252;
}

/* Nodes */
.node {
  position: absolute;
  width: 200px;
  background: #262626; /* Gray 90 */
  border: 1px solid #393939;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  cursor: grab;
  z-index: 1;
  user-select: none;
}

.node:active {
    cursor: grabbing;
}

.node.selected {
  box-shadow: 0 0 0 1px #4589ff; /* Blue 60 */
  z-index: 2;
}

.node-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  color: #ffffff;
  font-weight: 600;
}

.node-actions {
    display: flex;
    gap: 4px;
    align-items: center;
}

.node-action-btn, 
.node-close {
  background: rgba(0, 0, 0, 0.2);
  border: none;
  color: #ffffff;
  width: 20px;
  height: 20px;
  border-radius: 2px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  padding: 0;
  transition: background 0.1s;
}

.node-action-btn:hover,
.node-close:hover {
  background: rgba(0, 0, 0, 0.4);
}

.node-body {
  padding: 12px;
}

.node-name {
  font-size: 14px;
  font-weight: 400;
  color: #f4f4f4;
}

.node-id {
  font-size: 10px;
  color: #8d8d8d;
  margin-top: 4px;
  font-family: 'IBM Plex Mono', monospace;
}

/* AI Panel */
.ai-container {
    flex: 1;
    border: 1px solid #393939;
    background: #161616;
    overflow: hidden;
}

/* Buttons (Shared with Home) */
/* .primary-btn and .secondary-btn are global */

.full-width {
    width: 100%;
}

.small {
    padding: 6px 12px;
    font-size: 12px;
}

/* Terraform Modal */
.terraform-modal {
    position: fixed;
    bottom: 32px;
    right: 32px;
    width: 500px;
    max-width: 90vw;
    z-index: 100;
    box-shadow: 0 4px 24px rgba(0,0,0,0.5);
    border: 1px solid #525252;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.code-block {
  background: #161616;
  color: #f4f4f4;
  padding: 16px;
  border: 1px solid #393939;
  overflow-x: auto;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 12px;
  line-height: 1.5;
  height: 300px;
  overflow-y: auto;
}
</style>
